#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Patch pour le mod√®le d'IA afin d'am√©liorer la gestion des interactions utilisateur
"""

import logging
import re
import traceback
import requests
import time
import socket
import os

logger = logging.getLogger("VynalDocsAutomator.AIModelPatch")

# Cr√©er une session HTTP persistante pour reduire la latence
session = requests.Session()

# Variable globale pour suivre les erreurs d'Ollama
ollama_consecutive_failures = 0
ollama_disabled_until = 0

def should_use_ollama():
    """
    D√©termine si Ollama doit √™tre utilis√© en fonction des √©checs pr√©c√©dents.
    
    Returns:
        bool: True si Ollama doit √™tre utilis√©, False sinon
    """
    global ollama_consecutive_failures, ollama_disabled_until
    
    # Si Ollama est temporairement d√©sactiv√©
    if time.time() < ollama_disabled_until:
        return False
    
    # Si trop d'√©checs cons√©cutifs, v√©rifier Ollama
    if ollama_consecutive_failures >= 3:
        if check_ollama_running():
            # R√©initialiser le compteur d'√©checs
            ollama_consecutive_failures = 0
            return True
        else:
            # D√©sactiver Ollama pendant 60 secondes
            ollama_disabled_until = time.time() + 60
            logger.warning(f"Ollama d√©sactiv√© pendant 60 secondes suite √† {ollama_consecutive_failures} √©checs cons√©cutifs")
            return False
    
    return True

def check_ollama_running(url="http://localhost:11434/api/version", timeout=2):
    """
    V√©rifie si Ollama est en cours d'ex√©cution.
    
    Args:
        url (str): URL pour v√©rifier Ollama
        timeout (int): D√©lai d'attente en secondes
        
    Returns:
        bool: True si Ollama fonctionne, False sinon
    """
    try:
        response = session.get(url, timeout=timeout)
        return response.status_code == 200
    except (requests.RequestException, socket.error):
        return False

def patch_ai_model(AIModel):
    """
    Applique des patches au mod√®le d'IA pour am√©liorer la gestion des interactions utilisateur.
    
    Args:
        AIModel (class): La classe du mod√®le d'IA √† patcher
    """
    logger.info("Application des patches au mod√®le d'IA")
    
    # Sauvegarde des m√©thodes originales
    original_generate_response = AIModel.generate_response
    original_handle_user_choice = AIModel._handle_user_choice
    original_handle_model_actions = AIModel._handle_model_actions
    
    # Ajouter une propri√©t√© pour suivre si un menu est affich√©
    AIModel.menu_displayed = False
    
    # Remplacer la m√©thode originale _normalize_input si elle existe
    if hasattr(AIModel, '_normalize_input'):
        original_normalize_input = AIModel._normalize_input
        
        def enhanced_normalize_input(self, text):
            """
            Version am√©lior√©e de _normalize_input qui normalise plus efficacement les entr√©es
            """
            if not text:
                return ""
                
            # Appliquer la normalisation originale
            result = original_normalize_input(self, text)
            
            # Normalisation suppl√©mentaire pour les commandes courantes
            result = result.lower().strip()
            
            # Normaliser les variantes de "compl√©ter"
            if result in ["completer", "compl√©ter", "compl√©t√©", "complet√©", "complete", "terminer"]:
                return "completer"
                
            # Normaliser les variantes de "retour"
            if result in ["retour", "back", "pr√©c√©dent", "precedent", "annuler", "cancel"]:
                return "retour"
                
            # Normaliser les variantes de r√©initialisation
            if result in ["on reprend", "recommencer", "reset", "reinitialiser", "r√©initialiser"]:
                return "reset"
                
            return result
            
        AIModel._normalize_input = enhanced_normalize_input
    
    def patched_generate_response(self, message, stream=False):
        """
        Version am√©lior√©e de generate_response qui traite les remerciements et g√®re intelligemment
        les entr√©es utilisateur √† tout moment, tout en utilisant Llama pour r√©pondre aux questions g√©n√©rales.
        """
        try:
            # Ne pas traiter les messages vides
            if not message or len(message.strip()) == 0:
                return "Je n'ai pas compris votre message. Pourriez-vous reformuler?"
            
            # V√©rifier si c'est une commande de compl√©tion
            if message.strip().lower() in ["completer", "compl√©ter", "compl√©t√©", "terminer", "fini", "fin", "complete", "done", "finish", "end"]:
                logger.info("Commande de compl√©tion d√©tect√©e")
                
                # Si nous sommes en train de collecter des informations pour un formulaire
                if self.current_context["state"] == "collecting_form_info" and self.current_context.get("category") and self.current_context.get("model"):
                    logger.info("Compl√©tion du formulaire demand√©e")
                    
                    # CRITIQUE: V√©rifier si un _form_thread est d√©j√† en cours - √©viter les doubles appels
                    if getattr(self, '_form_thread_started', False):
                        logger.warning("Un thread de formulaire est d√©j√† en cours")
                        return "Je suis encore en train de traiter votre demande pr√©c√©dente. Veuillez patienter un instant."
                    
                    # IMPORTANT: R√©initialiser le contexte AVANT de lancer le traitement
                    # Cela garantit que m√™me si une exception se produit, le contexte est d√©j√† r√©initialis√©
                    category = self.current_context.get("category")
                    selected_model = self.current_context.get("model")
                    form_info = self.current_context.get("form_info", [])
                    
                    # R√©initialiser le contexte maintenant
                    logger.info("R√©initialisation du contexte AVANT de traiter la compl√©tion du document")
                    self.current_context = {
                        "state": "initial",
                        "last_action": "document_filled",
                        "subject": None,
                        "details": {},
                        "document_type": None,
                        "category": None,
                        "model": None,
                        "form_info": []
                    }
                    
                    # Lancer un thread pour le traitement du formulaire
                    # Cela √©vite de bloquer l'interface utilisateur
                    self._form_thread_started = True
                    
                    import threading
                    
                    # D√©finir la fonction √† ex√©cuter dans le thread
                    def launch_form_async():
                        try:
                            # 1. Essayer d'utiliser directement TemplateFormView
                            form_launched = False
                            try:
                                from views.template_view import TemplateFormView
                                
                                # Trouver la fen√™tre racine (root)
                                root = None
                                if hasattr(self, 'root'):
                                    root = self.root
                                elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'root'):
                                    root = self.appmodel.root
                                
                                if root:
                                    logger.info("Tentative d'ouverture directe de TemplateFormView")
                                    # Pr√©parer les donn√©es de template
                                    base_filename, extension = os.path.splitext(selected_model)
                                    template_data = {
                                        "name": f"{base_filename}",
                                        "type": category,
                                        "description": f"Document bas√© sur {selected_model}",
                                        "content": "",
                                        "variables": self._convert_form_info_to_variables(form_info),
                                        "original_file": document_path,
                                        "from_ai": True,
                                        "force_display": True,
                                        "show_dialog": True
                                    }
                                    
                                    # Instantier directement la vue
                                    template_form = TemplateFormView(
                                        root,
                                        self.appmodel if hasattr(self, 'appmodel') else self,
                                        template_data=template_data,
                                        update_view_callback=None
                                    )
                                    form_launched = True
                                    logger.info("TemplateFormView ouvert avec succ√®s")
                            except Exception as form_error:
                                logger.error(f"Erreur lors de l'ouverture directe de TemplateFormView: {form_error}")
                            
                            # 2. Essayer via le bouton du dashboard (simulation de clic)
                            if not form_launched:
                                logger.info("Tentative de simulation du clic sur bouton 'Cr√©er un mod√®le'")
                                button_clicked = self.simulate_create_template_button_click()
                                if button_clicked:
                                    logger.info("Bouton 'Cr√©er un mod√®le' cliqu√© avec succ√®s")
                                    form_launched = True
                            
                            # 3. Essayer via l'appmodel
                            if not form_launched:
                                # Si available, lancer le formulaire
                                if hasattr(self, 'appmodel'):
                                    for method_name in ['create_template', 'edit_template', 'show_template_form']:
                                        if hasattr(self.appmodel, method_name) and not form_launched:
                                            method = getattr(self.appmodel, method_name)
                                            try:
                                                # Pr√©parer les donn√©es
                                                base_filename, extension = os.path.splitext(selected_model)
                                                template_data = {
                                                    "name": f"{base_filename}",
                                                    "type": category,
                                                    "description": f"Document bas√© sur {selected_model}",
                                                    "content": "",
                                                    "variables": self._convert_form_info_to_variables(form_info),
                                                    "original_file": document_path,
                                                    "from_ai": True,
                                                    "force_display": True,
                                                    "show_dialog": True
                                                }
                                                
                                                method(template_data)
                                                logger.info(f"Formulaire lanc√© via appmodel.{method_name}")
                                                form_launched = True
                                                break
                                            except Exception as e:
                                                logger.error(f"Erreur avec appmodel.{method_name}: {e}")
                                                continue
                            
                            # 4. Tenter d'acc√©der au dashboard directement pour utiliser le bouton "Cr√©er un mod√®le"
                            if not form_launched:
                                logger.info("Recherche du dashboard pour cr√©er un mod√®le")
                                dashboard = None
                                
                                # Chercher dans tous les endroits possibles
                                if hasattr(self, 'dashboard'):
                                    dashboard = self.dashboard
                                elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'dashboard'):
                                    dashboard = self.appmodel.dashboard
                                elif hasattr(self, 'root') and hasattr(self.root, 'dashboard'):
                                    dashboard = self.root.dashboard
                                elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'root') and hasattr(self.appmodel.root, 'dashboard'):
                                    dashboard = self.appmodel.root.dashboard
                                
                                # Si dashboard trouv√©
                                if dashboard:
                                    logger.info("Dashboard trouv√©, tentative d'utilisation")
                                    
                                    # M√©thodes possibles qui pourraient lancer le formulaire
                                    methods_to_try = [
                                        'create_model', 'create_template', 'new_template', 'add_template',
                                        'open_template_form', 'show_template_form', 'create_new_template',
                                        'on_create_model_click', 'on_create_template_click', 'handle_create_model'
                                    ]
                                    
                                    # Tester chaque m√©thode
                                    for method_name in methods_to_try:
                                        if hasattr(dashboard, method_name) and not form_launched:
                                            try:
                                                method = getattr(dashboard, method_name)
                                                method()  # Essai sans param√®tres
                                                logger.info(f"M√©thode dashboard.{method_name} appel√©e avec succ√®s")
                                                form_launched = True
                                                break
                                            except Exception as e:
                                                logger.error(f"Erreur avec dashboard.{method_name}: {e}")
                                    
                                    # Simulation de clic sur le bouton si les m√©thodes directes √©chouent
                                    if not form_launched:
                                        # Chercher le bouton par attribut nomm√©
                                        if hasattr(dashboard, 'create_template_button'):
                                            logger.info("Bouton create_template_button trouv√©")
                                            try:
                                                dashboard.create_template_button.invoke()
                                                form_launched = True
                                            except Exception as e:
                                                logger.error(f"Erreur lors de l'appel √† invoke: {e}")
                                        elif hasattr(dashboard, 'new_template_btn'):
                                            logger.info("Bouton new_template_btn trouv√©")
                                            try:
                                                dashboard.new_template_btn.invoke()
                                                form_launched = True
                                            except Exception as e:
                                                logger.error(f"Erreur lors de l'appel √† invoke: {e}")
                                            
                                            # Chercher le bouton parmi les enfants du dashboard
                                            if not form_launched and hasattr(dashboard, 'winfo_children'):
                                                for child in dashboard.winfo_children():
                                                    try:
                                                        # Essayer d'obtenir le texte du widget
                                                        child_text = ""
                                                        if hasattr(child, 'cget') and callable(getattr(child, 'cget')):
                                                            try:
                                                                child_text = child.cget('text')
                                                            except:
                                                                pass
                                                        
                                                        # Si c'est le bouton, l'activer
                                                        if 'cr√©er' in str(child_text).lower() and 'mod√®le' in str(child_text).lower():
                                                            if hasattr(child, 'invoke') and callable(getattr(child, 'invoke')):
                                                                child.invoke()
                                                                logger.info(f"Bouton 'Cr√©er un mod√®le' trouv√© et activ√©")
                                                                form_launched = True
                                                                break
                                                    except Exception as e:
                                                        logger.error(f"Erreur avec un widget enfant: {e}")
                                                        continue
                            
                            # 5. Fallback: Ouvrir directement le document
                            if not form_launched and os.path.exists(document_path):
                                logger.warning("Aucune m√©thode n'a fonctionn√©, ouverture du document avec l'application par d√©faut")
                                import platform
                                system = platform.system()
                                if system == 'Windows':
                                    os.startfile(document_path)
                                elif system == 'Darwin':  # macOS
                                    import subprocess
                                    subprocess.call(['open', document_path])
                                else:  # Linux
                                    import subprocess
                                    subprocess.call(['xdg-open', document_path])
                                logger.info(f"Document ouvert directement: {document_path}")
                                
                                # Informer l'utilisateur via une bo√Æte de dialogue si possible
                                try:
                                    import tkinter as tk
                                    from tkinter import messagebox
                                    
                                    # Cr√©er une fen√™tre temporaire (invisible)
                                    temp_tk = tk.Tk()
                                    temp_tk.withdraw()  # Cacher la fen√™tre
                                    
                                    # Afficher le message
                                    messagebox.showinfo(
                                        "Ouverture du document",
                                        f"Le document '{selected_model}' a √©t√© ouvert directement.\n\n"
                                        "Pour le sauvegarder en tant que mod√®le, utilisez le bouton 'Cr√©er un mod√®le' dans l'application principale."
                                    )
                                    
                                    # D√©truire la fen√™tre temporaire
                                    temp_tk.destroy()
                                except Exception as tk_error:
                                    logger.error(f"Erreur lors de l'affichage du message: {tk_error}")
                        except Exception as e:
                            logger.error(f"Erreur dans thread de formulaire: {e}")
                            import traceback
                            logger.error(traceback.format_exc())
                    
                    # Lancer le thread
                    thread = threading.Thread(target=launch_form_async)
                    thread.daemon = True
                    thread.start()
                    logger.info("Thread de lancement de formulaire d√©marr√©")
                except Exception as thread_error:
                    logger.error(f"Erreur lors du lancement du thread: {thread_error}")
                    self._form_thread_started = False
            
            # Traiter les remerciements simples pour terminer poliment
            if self._is_simple_thanks(message) and not stream:
                logger.info("Remerciement simple d√©tect√©")
                if self.current_context["state"] != "initial":
                    logger.info("R√©initialisation du contexte apr√®s remerciement")
                    self._reset_context()
                return "De rien ! C'est un plaisir de vous aider. N'h√©sitez pas si vous avez besoin d'autre chose."
            
            # V√©rifier si l'utilisateur tente de donner plus d'informations pour un formulaire
            if self.current_context["state"] == "collecting_form_info":
                logger.info("Ajout d'informations au formulaire")
                self.current_context["form_info"].append(message)
                return "J'ai bien not√© cette information. Souhaitez-vous ajouter autre chose, ou taper 'compl√©ter' pour finaliser le document ?"
            
            # Parcourir le workflow d√©fini
            result = self._handle_workflow(message, stream)
            if result:
                return result
                
            # Si aucun workflow sp√©cifique n'a √©t√© activ√©, g√©n√©rer une r√©ponse via l'API Llama
            return self._generate_llama_response(message, stream)
        except Exception as e:
            logger.error(f"Erreur dans patched_generate_response: {e}")
            logger.error(traceback.format_exc())
            return f"Une erreur s'est produite lors du traitement de votre demande. Veuillez r√©essayer ou contacter l'assistance."
    
    def patched_handle_user_choice(self, user_input):
        """
        Version am√©lior√©e de _handle_user_choice qui g√®re mieux les entr√©es de l'utilisateur
        et les changements de contexte.
        """
        try:
            # V√©rifier si c'est une question simple ou salutation
            msg_lower = user_input.lower().strip()
            
            # V√©rifier les salutations
            greeting_patterns = [
                r'\bcava\b', r'\b√ßa va\b', r'\bcomment √ßa va\b', r'\bcomment vas[\s-]tu\b', 
                r'\bcomment tu vas\b', r'\bcomment tu va\b', r'\btu vas bien\b',
                r'\bcomment cv\b', r'\bcv\??\b', r'\bbonjour\b', r'\bsalut\b', r'\bhello\b'
            ]
            
            # Si c'est une simple salutation
            if any(re.search(pattern, msg_lower) for pattern in greeting_patterns) and len(user_input.split()) <= 3:
                current_state = self.current_context.get("state", "initial")
                
                # Si nous sommes au d√©but
                if current_state in ["initial", "greeting"]:
                    self.current_context["state"] = "greeting"
                    return "Je vais tr√®s bien, merci ! Comment puis-je vous aider avec vos documents aujourd'hui ?"
                
                # Si nous sommes au milieu d'un processus
                if current_state == "choosing_category":
                    return "Je vais bien, merci ! Pour continuer, veuillez choisir une cat√©gorie de document parmi celles propos√©es."
                elif current_state == "choosing_model":
                    return "Je vais bien, merci ! Pour continuer, veuillez choisir un mod√®le de document parmi ceux propos√©s."
                elif current_state == "model_selected":
                    return "Je vais bien, merci ! Pour continuer, que souhaitez-vous faire avec le document s√©lectionn√© ?"
                else:
                    return "Je vais bien, merci ! Continuons avec votre document. Comment puis-je vous aider ?"
            
            # V√©rifier si c'est une demande d'avis sur un document
            opinion_doc_patterns = [
                r'ton avis sur ce(tte)? doc(ument)?', r'penses[\s-]tu (de )?ce doc(ument)?',
                r'avis sur (le|ce) (document|mod√®le|fichier|template)',
                r'que penses[\s-]tu (de )?ce(tte)? (document|mod√®le|fichier|template)'
            ]
            
            is_opinion_doc_request = any(re.search(pattern, msg_lower) for pattern in opinion_doc_patterns)
            
            # Si l'utilisateur demande un avis sur un document sp√©cifique
            current_state = self.current_context.get("state", "initial")
            if is_opinion_doc_request and current_state in ["choosing_model", "model_selected"]:
                # Extraire le document actuellement s√©lectionn√© s'il existe
                current_model = self.current_context.get("model")
                current_category = self.current_context.get("category")
                
                if current_model and current_category:
                    # V√©rifier si Ollama est disponible et fiable
                    if should_use_ollama():
                        try:
                            # Cr√©er un prompt adapt√© pour l'avis sur le document
                            prompt = f"""Je suis un assistant IA qui aide √† cr√©er des documents. L'utilisateur me demande mon avis sur un document de type '{current_category}', nomm√© '{current_model}'. 
Comment puis-je lui donner un avis professionnel et utile sur ce document sans l'avoir vu, en me basant sur son type et son nom?"""
                            
                            # G√©n√©rer une r√©ponse avec Llama avec un d√©lai d'attente r√©duit
                            llama_response = self._get_llama_response(prompt)
                            
                            # Si Llama a r√©ussi √† g√©n√©rer une r√©ponse pertinente
                            if llama_response and len(llama_response) > 15:
                                context_reminder = "\n\nSi vous souhaitez utiliser ce document, vous pouvez :\n1Ô∏è‚É£ Le remplir maintenant\n2Ô∏è‚É£ L'utiliser tel quel\n\nVeuillez choisir en tapant 1 ou 2."
                                full_response = llama_response + context_reminder
                                
                                # Mettre √† jour l'√©tat
                                self.current_context["state"] = "model_selected"
                                
                                return full_response
                        except Exception as e:
                            logger.error(f"Erreur lors de la g√©n√©ration d'avis sur document: {e}")
                            logger.error(traceback.format_exc())
                    
                    # Si Ollama n'est pas disponible ou a √©chou√©, utiliser une r√©ponse par d√©faut
                    return f"Ce document '{current_model}' de la cat√©gorie '{current_category}' semble √™tre un bon choix pour votre besoin. Souhaitez-vous:\n1Ô∏è‚É£ Le remplir maintenant\n2Ô∏è‚É£ L'utiliser tel quel\n\nVeuillez choisir en tapant 1 ou 2."
                else:
                    # Si aucun document n'est encore s√©lectionn√©
                    return "Veuillez d'abord s√©lectionner un document sp√©cifique pour que je puisse vous donner mon avis dessus."
            
            # V√©rifier si c'est une demande courte de document
            doc_request_patterns = [
                r'\bdoc(s|ument)?\b', r'\bmodele\b', r'\bmod√®le\b', r'\bbesoin\b', r'\bveux\b', r'\bvoudrais\b'
            ]
            
            is_doc_request = any(re.search(pattern, msg_lower) for pattern in doc_request_patterns)
            
            # Si c'est un message court du type "je veux un docs", le traiter comme une demande de document
            if is_doc_request and len(user_input.split()) <= 5 and self.current_context.get("state") == "initial":
                # Traiter comme une demande de document
                self.current_context["state"] = "asking_document_type"
                return """üìå Que souhaitez-vous faire ?

1Ô∏è‚É£ Utiliser un mod√®le existant
2Ô∏è‚É£ Cr√©er un nouveau document

Veuillez choisir une option en tapant 1 ou 2."""
            
            # D√©tecter s'il s'agit d'une question g√©n√©rale ou d'une demande d'information
            general_question_patterns = [
                r'\bpourquoi\b', r'\bcomment\b', r'\bquand\b', r'\bo√π\b', r'\bqui\b', 
                r'\bquel\b', r'\bquelle\b', r'\bcombien\b', r'\bque\b', r'\bqu\'est(-ce)?(\s+que)?\b'
            ]
            
            # Patterns pour les demandes d'avis
            opinion_patterns = [
                r'\bqu\'en penses[\s-]tu\b', r'\bton avis\b', r'\bpenses[\s-]tu\b', 
                r'\bton opinion\b', r'\bque penses[\s-]tu\b'
            ]
            
            is_general_question = any(re.search(pattern, msg_lower) for pattern in general_question_patterns)
            is_opinion_request = any(re.search(pattern, msg_lower) for pattern in opinion_patterns)
            
            # Si c'est une question g√©n√©rale ou une demande d'avis pendant le processus
            current_state = self.current_context.get("state", "initial")
            if (is_opinion_request or (is_general_question and len(user_input.split()) > 3)) and current_state not in ["initial", "greeting"]:
                # Utiliser Llama pour r√©pondre tout en maintenant le contexte
                try:
                    # V√©rifier si Ollama est disponible
                    if not should_use_ollama():
                        logger.warning("Ollama n'est pas disponible dans _handle_user_choice. Utilisation du comportement standard.")
                        return original_handle_user_choice(self, user_input)
                        
                    # Adapter le prompt en fonction du type de question
                    if is_opinion_request:
                        prompt = f"L'utilisateur me demande mon avis pendant le processus de document: {user_input}. R√©ponds de fa√ßon sympathique et professionnelle."
                    else:
                        prompt = f"L'utilisateur me pose cette question pendant le processus de document: {user_input}. R√©ponds de fa√ßon concise et pr√©cise."
                    
                    # G√©n√©rer une r√©ponse avec Llama
                    llama_response = self._get_llama_response(prompt)
                    
                    # V√©rifier que la r√©ponse est valide
                    if llama_response and len(llama_response) > 15:
                        # D√©terminer un rappel du contexte bas√© sur l'√©tat actuel
                        if current_state == "choosing_category":
                            context_reminder = "\n\nPour revenir √† notre processus, veuillez choisir une cat√©gorie de document."
                        elif current_state == "choosing_model":
                            context_reminder = "\n\nPour revenir √† notre processus, veuillez choisir un mod√®le de document."
                        elif current_state == "model_selected":
                            context_reminder = "\n\nPour revenir √† notre processus, veuillez indiquer ce que vous souhaitez faire avec le document."
                        else:
                            context_reminder = "\n\nMaintenant, revenons √† votre document."
                        
                        return llama_response + context_reminder
                except Exception as e:
                    logger.error(f"Erreur lors de l'appel √† Llama dans _handle_user_choice: {e}")
                    # En cas d'erreur, continuer avec le comportement normal
            
            # Pour toute autre entr√©e utilisateur pendant le processus, essayer d'utiliser Llama
            if current_state not in ["initial", "greeting"] and len(user_input.split()) > 1:
                try:
                    # V√©rifier si Ollama est disponible
                    if not should_use_ollama():
                        logger.warning("Ollama n'est pas disponible pour le traitement g√©n√©ral dans _handle_user_choice. Utilisation du comportement standard.")
                        return original_handle_user_choice(self, user_input)
                        
                    # Cr√©er un prompt contextualis√©
                    prompt = f"Je suis un assistant IA qui aide √† cr√©er des documents. L'utilisateur est en train de {self._get_state_description(current_state)} et me dit: '{user_input}'. Comment dois-je interpr√©ter cette entr√©e et y r√©pondre de mani√®re utile?"
                    
                    # G√©n√©rer une r√©ponse avec Llama
                    llama_response = self._get_llama_response(prompt)
                    
                    # Si Llama a r√©ussi √† g√©n√©rer une r√©ponse pertinente
                    if llama_response and len(llama_response) > 15:
                        # Ajouter un rappel contextuel
                        if current_state == "choosing_category":
                            context_reminder = "\n\nVeuillez choisir une cat√©gorie de document pour continuer."
                        elif current_state == "choosing_model":
                            context_reminder = "\n\nVeuillez choisir un mod√®le de document pour continuer."
                        elif current_state == "model_selected":
                            context_reminder = "\n\nVeuillez indiquer ce que vous souhaitez faire avec le document."
                        else:
                            context_reminder = "\n\nContinuons avec votre document."
                        
                        return llama_response + context_reminder
                except Exception as e:
                    logger.error(f"Erreur lors de l'appel g√©n√©ral √† Llama dans _handle_user_choice: {e}")
                    # En cas d'erreur, continuer avec le comportement normal
            
            # Appliquer le comportement normal pour tous les autres cas
            return original_handle_user_choice(self, user_input)
            
        except Exception as e:
            # Capturer les erreurs et fournir une r√©ponse utile
            logger.error(f"Erreur dans _handle_user_choice: {e}")
            logger.error(traceback.format_exc())
            
            # R√©initialiser le contexte et reprendre depuis le d√©but
            self.current_context["state"] = "asking_document_type"
            return """Je suis d√©sol√©, j'ai perdu le contexte de notre conversation. Reprenons :

1Ô∏è‚É£ Utiliser un mod√®le existant
2Ô∏è‚É£ Cr√©er un nouveau document

Veuillez choisir une option en tapant 1 ou 2."""
            
    def patched_handle_model_actions(self, message):
        """
        Version am√©lior√©e de _handle_model_actions qui g√®re mieux les r√©ponses aux questions
        comme l'ouverture d'un document.
        """
        # Normaliser l'entr√©e pour la recherche
        normalized_input = self._normalize_input(message) if hasattr(self, '_normalize_input') else message.lower().strip()
        
        # Variables du contexte actuelles
        category = self.current_context.get("category", "")
        selected_model = self.current_context.get("model", "")
        last_action = self.current_context.get("last_action", "")
        current_state = self.current_context.get("state", "")
        
        # V√©rifier que le mod√®le et la cat√©gorie sont d√©finis
        if not category or not selected_model:
            self.current_context["state"] = "choosing_category"
            return self._show_available_categories()
        
        # FORCER la r√©initialisation imm√©diate pour les commandes de compl√©tion
        # Liste des commandes qui indiquent la fin du remplissage
        completion_commands = [
            "completer", "compl√©ter", "compl√©t√©", "complet√©", "complete", 
            "terminer", "fini", "finir", "done", "valider", "ok", "c'est tout"
        ]
        
        # V√©rifier explicitement si l'utilisateur essaie de terminer le remplissage du formulaire
        if last_action == "remplir_document" and normalized_input in completion_commands:
            logger.info(f"üö® COMMANDE DE COMPL√âTION CRITIQUE D√âTECT√âE: {message}")
            
            # Sauvegarder les informations essentielles avant la r√©initialisation
            saved_category = category
            saved_model = selected_model
            saved_form_info = self.current_context.get("form_info", []).copy()
            
            # IMPORTANT: R√âINITIALISATION IMM√âDIATE DU CONTEXTE AVANT TOUT TRAITEMENT
            logger.info("üîÑ R√âINITIALISATION CRITIQUE DU CONTEXTE AVANT TOUT")
            self.current_context = {
                "state": "initial",
                "last_action": "document_completed", # Marquer sp√©cifiquement cette action
                "subject": None,
                "details": {},
                "document_type": None,
                "category": None,
                "model": None,
                "form_info": []
            }
            
            # Ex√©cuter l'affichage du formulaire apr√®s la r√©initialisation
            logger.info(f"Tentative d'affichage du formulaire pour {saved_model} avec {len(saved_form_info)} infos")
            document_path = self.get_model_path(saved_category, saved_model)
            
            # Lancer l'interface graphique de mani√®re asynchrone
            try:
                import threading
                
                # D√©finir une fonction pour lancer le formulaire de mani√®re asynchrone
                def launch_form_async():
                    try:
                        # 1. Essayer d'utiliser directement TemplateFormView
                        form_launched = False
                        try:
                            from views.template_view import TemplateFormView
                            
                            # Trouver la fen√™tre racine (root)
                            root = None
                            if hasattr(self, 'root'):
                                root = self.root
                            elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'root'):
                                root = self.appmodel.root
                            
                            if root:
                                logger.info("Tentative d'ouverture directe de TemplateFormView")
                                # Pr√©parer les donn√©es de template
                                base_filename, extension = os.path.splitext(selected_model)
                                template_data = {
                                    "name": f"{base_filename}",
                                    "type": category,
                                    "description": f"Document bas√© sur {selected_model}",
                                    "content": "",
                                    "variables": self._convert_form_info_to_variables(saved_form_info),
                                    "original_file": document_path,
                                    "from_ai": True,
                                    "force_display": True,
                                    "show_dialog": True
                                }
                                
                                # Instantier directement la vue
                                template_form = TemplateFormView(
                                    root,
                                    self.appmodel if hasattr(self, 'appmodel') else self,
                                    template_data=template_data,
                                    update_view_callback=None
                                )
                                form_launched = True
                                logger.info("TemplateFormView ouvert avec succ√®s")
                        except Exception as form_error:
                            logger.error(f"Erreur lors de l'ouverture directe de TemplateFormView: {form_error}")
                        
                        # 2. Essayer via le bouton du dashboard (simulation de clic)
                        if not form_launched:
                            logger.info("Tentative de simulation du clic sur bouton 'Cr√©er un mod√®le'")
                            button_clicked = self.simulate_create_template_button_click()
                            if button_clicked:
                                logger.info("Bouton 'Cr√©er un mod√®le' cliqu√© avec succ√®s")
                                form_launched = True
                        
                        # 3. Essayer via l'appmodel
                        if not form_launched:
                            # Si available, lancer le formulaire
                            if hasattr(self, 'appmodel'):
                                for method_name in ['create_template', 'edit_template', 'show_template_form']:
                                    if hasattr(self.appmodel, method_name) and not form_launched:
                                        method = getattr(self.appmodel, method_name)
                                        try:
                                            # Pr√©parer les donn√©es
                                            base_filename, extension = os.path.splitext(selected_model)
                                            template_data = {
                                                "name": f"{base_filename}",
                                                "type": category,
                                                "description": f"Document bas√© sur {selected_model}",
                                                "content": "",
                                                "variables": self._convert_form_info_to_variables(saved_form_info),
                                                "original_file": document_path,
                                                "from_ai": True,
                                                "force_display": True,
                                                "show_dialog": True
                                            }
                                            
                                            method(template_data)
                                            logger.info(f"Formulaire lanc√© via appmodel.{method_name}")
                                            form_launched = True
                                            break
                                        except Exception as e:
                                            logger.error(f"Erreur avec appmodel.{method_name}: {e}")
                                            continue
                        
                        # 4. Tenter d'acc√©der au dashboard directement pour utiliser le bouton "Cr√©er un mod√®le"
                        if not form_launched:
                            logger.info("Recherche du dashboard pour cr√©er un mod√®le")
                            dashboard = None
                            
                            # Chercher dans tous les endroits possibles
                            if hasattr(self, 'dashboard'):
                                dashboard = self.dashboard
                            elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'dashboard'):
                                dashboard = self.appmodel.dashboard
                            elif hasattr(self, 'root') and hasattr(self.root, 'dashboard'):
                                dashboard = self.root.dashboard
                            elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'root') and hasattr(self.appmodel.root, 'dashboard'):
                                dashboard = self.appmodel.root.dashboard
                            
                            # Si dashboard trouv√©
                            if dashboard:
                                logger.info("Dashboard trouv√©, tentative d'utilisation")
                                
                                # M√©thodes possibles qui pourraient lancer le formulaire
                                methods_to_try = [
                                    'create_model', 'create_template', 'new_template', 'add_template',
                                    'open_template_form', 'show_template_form', 'create_new_template',
                                    'on_create_model_click', 'on_create_template_click', 'handle_create_model'
                                ]
                                
                                # Tester chaque m√©thode
                                for method_name in methods_to_try:
                                    if hasattr(dashboard, method_name) and not form_launched:
                                        try:
                                            method = getattr(dashboard, method_name)
                                            method()  # Essai sans param√®tres
                                            logger.info(f"M√©thode dashboard.{method_name} appel√©e avec succ√®s")
                                            form_launched = True
                                            break
                                        except Exception as e:
                                            logger.error(f"Erreur avec dashboard.{method_name}: {e}")
                                
                                # Simulation de clic sur le bouton si les m√©thodes directes √©chouent
                                if not form_launched:
                                    # Chercher le bouton par attribut nomm√©
                                    if hasattr(dashboard, 'create_template_button'):
                                        logger.info("Bouton create_template_button trouv√©")
                                        try:
                                            dashboard.create_template_button.invoke()
                                            form_launched = True
                                        except Exception as e:
                                            logger.error(f"Erreur lors de l'appel √† invoke: {e}")
                                    elif hasattr(dashboard, 'new_template_btn'):
                                        logger.info("Bouton new_template_btn trouv√©")
                                        try:
                                            dashboard.new_template_btn.invoke()
                                            form_launched = True
                                        except Exception as e:
                                            logger.error(f"Erreur lors de l'appel √† invoke: {e}")
                                        
                                        # Chercher le bouton parmi les enfants du dashboard
                                        if not form_launched and hasattr(dashboard, 'winfo_children'):
                                            for child in dashboard.winfo_children():
                                                try:
                                                    # Essayer d'obtenir le texte du widget
                                                    child_text = ""
                                                    if hasattr(child, 'cget') and callable(getattr(child, 'cget')):
                                                        try:
                                                            child_text = child.cget('text')
                                                        except:
                                                            pass
                                                    
                                                    # Si c'est le bouton, l'activer
                                                    if 'cr√©er' in str(child_text).lower() and 'mod√®le' in str(child_text).lower():
                                                        if hasattr(child, 'invoke') and callable(getattr(child, 'invoke')):
                                                            child.invoke()
                                                            logger.info(f"Bouton 'Cr√©er un mod√®le' trouv√© et activ√©")
                                                            form_launched = True
                                                            break
                                                except Exception as e:
                                                    logger.error(f"Erreur avec un widget enfant: {e}")
                                                    continue
                            
                                # 5. Fallback: Ouvrir directement le document
                                if not form_launched and os.path.exists(document_path):
                                    logger.warning("Aucune m√©thode n'a fonctionn√©, ouverture du document avec l'application par d√©faut")
                                    import platform
                                    system = platform.system()
                                    if system == 'Windows':
                                        os.startfile(document_path)
                                    elif system == 'Darwin':  # macOS
                                        import subprocess
                                        subprocess.call(['open', document_path])
                                    else:  # Linux
                                        import subprocess
                                        subprocess.call(['xdg-open', document_path])
                                    logger.info(f"Document ouvert directement: {document_path}")
                                    
                                    # Informer l'utilisateur via une bo√Æte de dialogue si possible
                                    try:
                                        import tkinter as tk
                                        from tkinter import messagebox
                                        
                                        # Cr√©er une fen√™tre temporaire (invisible)
                                        temp_tk = tk.Tk()
                                        temp_tk.withdraw()  # Cacher la fen√™tre
                                        
                                        # Afficher le message
                                        messagebox.showinfo(
                                            "Ouverture du document",
                                            f"Le document '{selected_model}' a √©t√© ouvert directement.\n\n"
                                            "Pour le sauvegarder en tant que mod√®le, utilisez le bouton 'Cr√©er un mod√®le' dans l'application principale."
                                        )
                                        
                                        # D√©truire la fen√™tre temporaire
                                        temp_tk.destroy()
                                    except Exception as tk_error:
                                        logger.error(f"Erreur lors de l'affichage du message: {tk_error}")
                        except Exception as e:
                            logger.error(f"Erreur dans thread de formulaire: {e}")
                            import traceback
                            logger.error(traceback.format_exc())
                    
                    # Lancer le thread
                    thread = threading.Thread(target=launch_form_async)
                    thread.daemon = True
                    thread.start()
                    logger.info("Thread de lancement de formulaire d√©marr√©")
                
            except Exception as thread_error:
                logger.error(f"Erreur lors du lancement du thread: {thread_error}")
            
            # Toujours retourner le message de confirmation
            return f"""‚úÖ Je vais maintenant compl√©ter le document "{saved_model}" avec les informations suivantes:

{chr(10).join([f"- {info}" for info in saved_form_info])}

Je lance maintenant l'√©diteur de mod√®le pour finaliser le document.

Si vous ne voyez pas l'√©diteur appara√Ætre, veuillez chercher parmi les fen√™tres ouvertes
ou cliquer sur le bouton "Cr√©er un mod√®le" dans l'interface principale."""
        
        # V√©rifier si l'utilisateur refuse de continuer le remplissage
        if last_action == "remplir_document" and normalized_input in ["non", "no", "stop", "annuler", "arreter", "arr√™ter"]:
            # R√âINITIALISER le contexte imm√©diatement ici aussi
            logger.info("R√©initialisation du contexte apr√®s annulation du remplissage")
            self.current_context = {
                "state": "initial",
                "last_action": "document_filling_cancelled",
                "subject": None,
                "details": {},
                "document_type": None,
                "category": None,
                "model": None,
                "form_info": []
            }
            
            return f"""‚úÖ D'accord, j'arr√™te le remplissage du document.

Que puis-je faire d'autre pour vous aider ?"""
        
        # Traiter sp√©cifiquement les commandes de navigation
        if normalized_input in ["retour", "back", "revenir", "precedent", "pr√©c√©dent", "annuler", "cancel"]:
            logger.info(f"Commande de retour d√©tect√©e: {message}, √©tat actuel: {current_state}")
            
            # Si nous sommes en mode mod√®le s√©lectionn√©, revenir √† la liste des mod√®les
            if current_state == "model_selected":
                self.current_context["state"] = "choosing_model"
                self.current_context["model"] = None
                self.current_context["last_action"] = "retour_liste_modeles"
                return self._show_available_models(category)
            
            return original_handle_model_actions(self, message)
        
        # Traiter sp√©cifiquement les commandes de r√©initialisation
        if normalized_input in ["on reprend", "rien", "recommencer", "reset", "reinitialiser", "r√©initialiser"]:
            logger.info("Commande de r√©initialisation d√©tect√©e")
            
            # R√©initialiser compl√®tement le contexte
            self.current_context = {
                "state": "initial",
                "last_action": "reinitialisation",
                "subject": None,
                "details": {},
                "document_type": None,
                "category": None,
                "model": None,
                "form_info": []
            }
            
            return """‚úÖ D'accord, recommen√ßons depuis le d√©but.

Comment puis-je vous aider ?
1Ô∏è‚É£ Utiliser un mod√®le existant
2Ô∏è‚É£ Cr√©er un nouveau document"""
        
        # V√©rifier si l'utilisateur confirme l'ouverture du document apr√®s "Utiliser tel quel"
        if last_action == "utiliser_document" and normalized_input in ["oui", "yes", "ok", "bien", "d'accord", "ouai", "oui", "ouais", "yep", "oui j'aimerais", "oui merci", "oui s'il vous plait", "oui svp"]:
            try:
                # Tenter d'ouvrir le document
                self._open_document(os.path.join(self.models_path, category, selected_model))
                # R√©initialiser le contexte
                self.current_context = {
                    "state": "initial",
                    "last_action": "document_opened",
                    "subject": None,
                    "details": {},
                    "document_type": None,
                    "category": None,
                    "model": None,
                    "form_info": []
                }
                return f"""‚úÖ J'ouvre le document "{selected_model}" pour vous.

üìÇ Vous pouvez le trouver √†: {os.path.join(self.models_path, category, selected_model)}

Avez-vous besoin d'autre chose ?"""
            except Exception as e:
                logger.error(f"Erreur lors de l'ouverture du document: {e}")
                return f"""‚ùå Je n'ai pas pu ouvrir le document "{selected_model}".

Vous pouvez le trouver manuellement √†: {os.path.join(self.models_path, category, selected_model)}

Avez-vous besoin d'autre chose ?"""
        
        # V√©rifier si l'utilisateur refuse l'ouverture du document
        if last_action == "utiliser_document" and normalized_input in ["non", "no", "pas maintenant", "plus tard", "nope", "non merci", "pas besoin"]:
            # R√©initialiser le contexte
            self.current_context = {
                "state": "initial",
                "last_action": "document_not_opened",
                "subject": None,
                "details": {},
                "document_type": None,
                "category": None,
                "model": None,
                "form_info": []
            }
            return """D'accord, je n'ouvrirai pas le document.

Est-ce que je peux vous aider avec autre chose ?"""
        
        # Utiliser la m√©thode originale pour tous les autres cas
        return original_handle_model_actions(self, message)
    
    def _get_llama_response(self, message):
        """
        G√©n√®re une r√©ponse en utilisant le mod√®le Llama pour les questions g√©n√©rales.
        
        Args:
            message (str): Le message de l'utilisateur ou prompt pour Llama
            
        Returns:
            str: La r√©ponse g√©n√©r√©e
        """
        global ollama_consecutive_failures
        
        try:
            # Construire un prompt appropri√© pour Llama
            prompt = f"""Tu es un assistant IA amical et professionnel sp√©cialis√© dans la cr√©ation de documents. 
R√©ponds √† la question de mani√®re concise et directe, en restant informatif et utile.
N'inclus pas de pr√©fixes comme "En tant qu'assistant IA" ou "Je suis un mod√®le de langage".
Garde tes r√©ponses courtes et pr√©cises.

{message}

R√©ponse:"""
            
            # Param√®tres pour l'API
            params = {
                "model": self.model if hasattr(self, 'model') else "llama3:latest",
                "prompt": prompt,
                "stream": False,
                "temperature": 0.7,
                "max_tokens": 150,  # R√©duire la longueur des r√©ponses pour √©viter les timeouts
                "top_p": 0.9,
                "stop": ["Question:", "R√©ponse:", "\n\n"]
            }
            
            # URL de l'API Ollama
            api_url = "http://localhost:11434/api/generate"
            
            # Appel √† l'API avec la session persistante et un timeout r√©duit
            response = session.post(
                api_url,
                json=params,
                timeout=10  # R√©duire le timeout pour √©viter les longues attentes
            )
            
            if response.status_code == 200:
                result = response.json()
                if "response" in result:
                    # R√©initialiser le compteur d'√©checs
                    ollama_consecutive_failures = 0
                    
                    # Nettoyer la r√©ponse
                    llama_response = result["response"].strip()
                    # Supprimer les pr√©fixes comme "En tant qu'assistant IA"
                    prefixes = [
                        "En tant qu'assistant IA,", "Je suis un mod√®le de langage,", 
                        "En tant que mod√®le IA,", "Je suis un assistant IA,",
                        "En tant qu'assistant", "Je suis un assistant", "En tant qu'IA"
                    ]
                    for prefix in prefixes:
                        if llama_response.lower().startswith(prefix.lower()):
                            llama_response = llama_response[len(prefix):].strip()
                            if llama_response.startswith(","):  # Enlever la virgule si elle est pr√©sente
                                llama_response = llama_response[1:].strip()
                    
                    return llama_response
            
            # Incr√©menter le compteur d'√©checs en cas de r√©ponse non-200
            ollama_consecutive_failures += 1
            logger.warning(f"√âchec d'appel √† Ollama, code: {response.status_code}. √âchecs cons√©cutifs: {ollama_consecutive_failures}")
            
            # R√©ponse par d√©faut en cas d'√©chec
            return None
            
        except Exception as e:
            # Incr√©menter le compteur d'√©checs en cas d'exception
            ollama_consecutive_failures += 1
            logger.error(f"Erreur lors de la g√©n√©ration de r√©ponse avec Llama: {e}")
            logger.error(f"√âchecs cons√©cutifs: {ollama_consecutive_failures}")
            return None
    
    def _get_state_description(self, state):
        """
        G√©n√®re une description textuelle de l'√©tat actuel pour le prompt Llama.
        
        Args:
            state (str): L'√©tat actuel de la conversation
            
        Returns:
            str: Description textuelle de l'√©tat
        """
        if state == "choosing_category":
            return "est en train de choisir une cat√©gorie de document parmi une liste propos√©e"
        elif state == "choosing_model":
            return "est en train de s√©lectionner un mod√®le de document sp√©cifique dans une cat√©gorie"
        elif state == "model_selected":
            return "a s√©lectionn√© un mod√®le de document et doit choisir quoi faire avec (le remplir, le pr√©visualiser, etc.)"
        elif state == "filling_document":
            return "est en train de remplir un formulaire pour un document"
        else:
            return "est dans une √©tape du processus de gestion de documents"
    
    # Initialiser la connexion Ollama au d√©marrage
    logger.info("V√©rification de la disponibilit√© d'Ollama...")
    ollama_available = check_ollama_running()
    if ollama_available:
        logger.info("Ollama est disponible et pr√™t √† √™tre utilis√©")
        # R√©initialiser les compteurs
        ollama_consecutive_failures = 0
        ollama_disabled_until = 0
    else:
        logger.warning("Ollama n'est pas disponible. Les r√©ponses LLM seront d√©sactiv√©es.")
        # D√©sactiver Ollama pendant 30 secondes
        ollama_disabled_until = time.time() + 30
            
    # Cr√©er une m√©thode pour intercepter le remplissage de document
    def intercept_document_filling(self, original_handle_model_actions):
        """
        Cr√©e une fonction qui intercepte le processus de remplissage de document 
        pour traiter correctement les commandes comme "compl√©ter"
        
        Args:
            original_handle_model_actions: La m√©thode originale _handle_model_actions
            
        Returns:
            function: La m√©thode modifi√©e
        """
        
        def intercepted_handle_model_actions(self, message):
            """
            Version de _handle_model_actions qui intercepte les commandes 
            de compl√©tion et √©vite qu'elles ne soient ajout√©es au formulaire
            """
            # V√©rifier si l'√©tat actuel est remplir_document
            if self.current_context.get("last_action") == "remplir_document":
                # Normaliser et v√©rifier si c'est une commande de compl√©tion
                if self.is_complete_command(message):
                    logger.info(f"Commande de compl√©tion intercept√©e dans _handle_model_actions: {message}")
                    # Traiter la compl√©tion sans ajouter le message au formulaire
                    return self._process_form_completion()
            
            # Si ce n'est pas une commande de compl√©tion, continuer normalement
            return original_handle_model_actions(self, message)
            
        return intercepted_handle_model_actions
        
    # Remplacer les m√©thodes originales par les versions patch√©es
    intercepted_handle_model_actions = intercept_document_filling(AIModel, original_handle_model_actions)
    
    # Remplacer les m√©thodes originales par les versions patch√©es
    AIModel.generate_response = patched_generate_response
    AIModel._handle_user_choice = patched_handle_user_choice
    AIModel._handle_model_actions = intercepted_handle_model_actions
    AIModel._get_llama_response = _get_llama_response
    AIModel._get_state_description = _get_state_description
    
    # Ajouter une m√©thode pour d√©tecter si une entr√©e est un num√©ro ou une r√©f√©rence √† un document
    def is_document_reference(self, user_input):
        """
        D√©tecte si l'entr√©e utilisateur fait r√©f√©rence √† un document (num√©ro ou nom de fichier)
        
        Args:
            user_input (str): L'entr√©e de l'utilisateur
            
        Returns:
            bool: True si l'entr√©e semble √™tre une r√©f√©rence √† un document
        """
        # V√©rifier si c'est un num√©ro simple
        if user_input.strip().isdigit():
            return True
            
        # V√©rifier les extensions de fichiers courants
        if any(ext in user_input.lower() for ext in ['.docx', '.pdf', '.doc', '.txt', '.odt']):
            return True
            
        return False
    
    AIModel.is_document_reference = is_document_reference
    
    # Fonction pour d√©tecter les mots-cl√©s de retour
    def is_return_command(self, user_input):
        """
        D√©tecte si l'entr√©e utilisateur est une commande de retour
        
        Args:
            user_input (str): L'entr√©e de l'utilisateur
            
        Returns:
            bool: True si l'entr√©e est une commande de retour
        """
        normalized = self._normalize_input(user_input)
        return normalized in ["retour", "back", "revenir", "precedent", "pr√©c√©dent", "annuler", "cancel"]
    
    # Fonction pour d√©tecter les mots-cl√©s de r√©initialisation
    def is_reset_command(self, user_input):
        """
        D√©tecte si l'entr√©e utilisateur est une commande de r√©initialisation
        
        Args:
            user_input (str): L'entr√©e de l'utilisateur
            
        Returns:
            bool: True si l'entr√©e est une commande de r√©initialisation
        """
        normalized = self._normalize_input(user_input)
        return normalized in ["on reprend", "rien", "recommencer", "reset", "reinitialiser", "r√©initialiser"]
    
    # Fonction g√©n√©rale pour r√©initialiser le contexte
    def reset_context(self):
        """
        R√©initialise compl√®tement le contexte de conversation
        
        Returns:
            dict: Le nouveau contexte r√©initialis√©
        """
        return {
            "state": "initial",
            "last_action": "reinitialisation",
            "subject": None,
            "details": {},
            "document_type": None,
            "category": None,
            "model": None,
            "form_info": []
        }
    
    # Fonction pour d√©tecter les mots-cl√©s de compl√©tion
    def is_complete_command(self, user_input):
        """
        D√©tecte si l'entr√©e utilisateur est une commande de compl√©tion
        
        Args:
            user_input (str): L'entr√©e de l'utilisateur
            
        Returns:
            bool: True si l'entr√©e est une commande de compl√©tion
        """
        normalized = self._normalize_input(user_input)
        return normalized in ["completer", "compl√©ter", "terminer", "valider", "ok", "fini", "finir", "done", "complete"]
    
    # Ajouter les nouvelles m√©thodes √† l'objet AIModel
    AIModel.is_return_command = is_return_command
    AIModel.is_reset_command = is_reset_command
    AIModel.is_complete_command = is_complete_command
    AIModel.reset_context = reset_context
    
    # Ajouter une m√©thode pour traiter la compl√©tion de formulaire
    def _process_form_completion(self):
        """
        Traite la compl√©tion d'un formulaire en lan√ßant l'interface appropri√©e de cr√©ation de mod√®le
        
        Returns:
            str: Message de confirmation ou d'erreur
        """
        try:
            # R√©cup√©rer les informations du contexte
            category = self.current_context.get("category", "")
            selected_model = self.current_context.get("model", "")
            form_info = self.current_context.get("form_info", [])
            
            # *** IMPORTANT: R√©initialiser le contexte AVANT de faire quoi que ce soit d'autre ***
            # Cela garantit que m√™me si une exception se produit, le contexte est d√©j√† r√©initialis√©
            logger.info("R√©initialisation du contexte AVANT de traiter la compl√©tion du document")
            self.current_context = {
                "state": "initial",
                "last_action": "document_filled",
                "subject": None,
                "details": {},
                "document_type": None,
                "category": None,
                "model": None,
                "form_info": []
            }
            
            if not category or not selected_model:
                logger.error("Tentative de compl√©tion sans cat√©gorie ou mod√®le d√©fini")
                return "Une erreur s'est produite : aucun document n'a √©t√© s√©lectionn√©. Veuillez recommencer."
                
            if not form_info:
                logger.warning("Tentative de compl√©tion sans informations de formulaire")
                return "Vous n'avez pas encore fourni d'informations pour ce document. Veuillez saisir les informations que vous souhaitez inclure."
            
            # Construire le chemin du document
            document_path = self.get_model_path(category, selected_model)
            logger.info(f"Chemin du document: {document_path}")
            
            # G√©n√©rer un nouveau nom pour le document rempli
            base_filename, extension = os.path.splitext(selected_model)
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            filled_filename = f"{base_filename}_rempli_{timestamp}{extension}"
            
            # Pr√©parer les donn√©es pour le formulaire de mod√®le
            template_data = {
                "name": f"{base_filename}",
                "type": category,
                "description": f"Document bas√© sur {selected_model}",
                "content": "", # Sera rempli par le formulaire
                "variables": self._convert_form_info_to_variables(form_info),
                "original_file": document_path,
                "from_ai": True,
                "bring_to_front": True,
                # Forcer l'affichage du formulaire
                "force_display": True,
                "show_dialog": True
            }
            
            logger.info(f"Lancement du formulaire de mod√®le pour {document_path} avec les informations: {form_info}")
            
            # Variable pour suivre si le formulaire a √©t√© ouvert avec succ√®s
            form_opened = False
            error_message = ""
            
            # M√âTHODE 1: Simuler le clic sur "Cr√©er un mod√®le"
            try:
                if hasattr(self, 'views') and hasattr(self.views, 'template_view'):
                    logger.info("Tentative d'acc√®s direct √† la vue de mod√®le")
                    if hasattr(self.views.template_view, 'create_template'):
                        logger.info("Utilisation de views.template_view.create_template")
                        self.views.template_view.create_template(template_data)
                        form_opened = True
                    elif hasattr(self.views.template_view, 'show_template_form'):
                        logger.info("Utilisation de views.template_view.show_template_form")
                        self.views.template_view.show_template_form(template_data)
                        form_opened = True
            except Exception as template_view_error:
                logger.error(f"Erreur lors de l'acc√®s √† template_view: {template_view_error}")
            
            # M√âTHODE 2: Utiliser les m√©thodes du contr√¥leur de template
            if not form_opened:
                try:
                    if hasattr(self, 'controllers') and hasattr(self.controllers, 'template_controller'):
                        controller = self.controllers.template_controller
                        logger.info("Acc√®s au contr√¥leur de template")
                        
                        # Essayer diff√©rentes m√©thodes du contr√¥leur
                        if hasattr(controller, 'create_new_template'):
                            logger.info("Utilisation de create_new_template")
                            controller.create_new_template(template_data)
                            form_opened = True
                        elif hasattr(controller, 'show_template_form'):
                            logger.info("Utilisation de show_template_form")
                            controller.show_template_form(template_data)
                            form_opened = True
                        elif hasattr(controller, 'edit_template'):
                            logger.info("Utilisation de edit_template")
                            controller.edit_template(category, selected_model, template_data)
                            form_opened = True
                except Exception as controller_error:
                    logger.error(f"Erreur lors de l'acc√®s au contr√¥leur: {controller_error}")
            
            # M√âTHODE 3: Utiliser l'app model
            if not form_opened:
                try:
                    if hasattr(self, 'appmodel'):
                        logger.info("Acc√®s √† l'appmodel")
                        # Essayer diff√©rentes m√©thodes de l'appmodel
                        if hasattr(self.appmodel, 'create_template'):
                            logger.info("Utilisation de appmodel.create_template")
                            self.appmodel.create_template(template_data)
                            form_opened = True
                        elif hasattr(self.appmodel, 'edit_template'):
                            logger.info("Utilisation de appmodel.edit_template")
                            self.appmodel.edit_template(template_data)
                            form_opened = True
                        elif hasattr(self.appmodel, 'show_template_form'):
                            logger.info("Utilisation de appmodel.show_template_form")
                            self.appmodel.show_template_form(template_data)
                            form_opened = True
                except Exception as appmodel_error:
                    logger.error(f"Erreur lors de l'acc√®s √† l'appmodel: {appmodel_error}")
            
            # M√âTHODE 4: Cr√©er directement l'interface depuis les vues
            if not form_opened:
                try:
                    import threading
                    
                    # D√©finir une fonction pour lancer le formulaire de mani√®re asynchrone
                    def launch_form_async():
                        try:
                            # 1. Essayer d'utiliser directement TemplateFormView
                            form_launched = False
                            try:
                                from views.template_view import TemplateFormView
                                
                                # Trouver la fen√™tre racine (root)
                                root = None
                                if hasattr(self, 'root'):
                                    root = self.root
                                elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'root'):
                                    root = self.appmodel.root
                                
                                if root:
                                    logger.info("Tentative d'ouverture directe de TemplateFormView")
                                    # Pr√©parer les donn√©es de template
                                    base_filename, extension = os.path.splitext(selected_model)
                                    template_data = {
                                        "name": f"{base_filename}",
                                        "type": category,
                                        "description": f"Document bas√© sur {selected_model}",
                                        "content": "",
                                        "variables": self._convert_form_info_to_variables(form_info),
                                        "original_file": document_path,
                                        "from_ai": True,
                                        "force_display": True,
                                        "show_dialog": True
                                    }
                                    
                                    # Instantier directement la vue
                                    template_form = TemplateFormView(
                                        root,
                                        self.appmodel if hasattr(self, 'appmodel') else self,
                                        template_data=template_data,
                                        update_view_callback=None
                                    )
                                    form_launched = True
                                    logger.info("TemplateFormView ouvert avec succ√®s")
                            except Exception as form_error:
                                logger.error(f"Erreur lors de l'ouverture directe de TemplateFormView: {form_error}")
                            
                            # 2. Essayer via le bouton du dashboard (simulation de clic)
                            if not form_launched:
                                logger.info("Tentative de simulation du clic sur bouton 'Cr√©er un mod√®le'")
                                button_clicked = self.simulate_create_template_button_click()
                                if button_clicked:
                                    logger.info("Bouton 'Cr√©er un mod√®le' cliqu√© avec succ√®s")
                                    form_launched = True
                            
                            # 3. Essayer via l'appmodel
                            if not form_launched:
                                # Si available, lancer le formulaire
                                if hasattr(self, 'appmodel'):
                                    for method_name in ['create_template', 'edit_template', 'show_template_form']:
                                        if hasattr(self.appmodel, method_name) and not form_launched:
                                            method = getattr(self.appmodel, method_name)
                                            try:
                                                # Pr√©parer les donn√©es
                                                base_filename, extension = os.path.splitext(selected_model)
                                                template_data = {
                                                    "name": f"{base_filename}",
                                                    "type": category,
                                                    "description": f"Document bas√© sur {selected_model}",
                                                    "content": "",
                                                    "variables": self._convert_form_info_to_variables(form_info),
                                                    "original_file": document_path,
                                                    "from_ai": True,
                                                    "force_display": True,
                                                    "show_dialog": True
                                                }
                                                
                                                method(template_data)
                                                logger.info(f"Formulaire lanc√© via appmodel.{method_name}")
                                                form_launched = True
                                                break
                                            except Exception as e:
                                                logger.error(f"Erreur avec appmodel.{method_name}: {e}")
                                                continue
                            
                            # 4. Tenter d'acc√©der au dashboard directement pour utiliser le bouton "Cr√©er un mod√®le"
                            if not form_launched:
                                logger.info("Recherche du dashboard pour cr√©er un mod√®le")
                                dashboard = None
                                
                                # Chercher dans tous les endroits possibles
                                if hasattr(self, 'dashboard'):
                                    dashboard = self.dashboard
                                elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'dashboard'):
                                    dashboard = self.appmodel.dashboard
                                elif hasattr(self, 'root') and hasattr(self.root, 'dashboard'):
                                    dashboard = self.root.dashboard
                                elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'root') and hasattr(self.appmodel.root, 'dashboard'):
                                    dashboard = self.appmodel.root.dashboard
                                
                                # Si dashboard trouv√©
                                if dashboard:
                                    logger.info("Dashboard trouv√©, tentative d'utilisation")
                                    
                                    # M√©thodes possibles qui pourraient lancer le formulaire
                                    methods_to_try = [
                                        'create_model', 'create_template', 'new_template', 'add_template',
                                        'open_template_form', 'show_template_form', 'create_new_template',
                                        'on_create_model_click', 'on_create_template_click', 'handle_create_model'
                                    ]
                                    
                                    # Tester chaque m√©thode
                                    for method_name in methods_to_try:
                                        if hasattr(dashboard, method_name) and not form_launched:
                                            try:
                                                method = getattr(dashboard, method_name)
                                                method()  # Essai sans param√®tres
                                                logger.info(f"M√©thode dashboard.{method_name} appel√©e avec succ√®s")
                                                form_launched = True
                                                break
                                            except Exception as e:
                                                logger.error(f"Erreur avec dashboard.{method_name}: {e}")
                                    
                                    # Simulation de clic sur le bouton si les m√©thodes directes √©chouent
                                    if not form_launched:
                                        # Chercher le bouton par attribut nomm√©
                                        if hasattr(dashboard, 'create_template_button'):
                                            logger.info("Bouton create_template_button trouv√©")
                                            try:
                                                dashboard.create_template_button.invoke()
                                                form_launched = True
                                            except Exception as e:
                                                logger.error(f"Erreur lors de l'appel √† invoke: {e}")
                                        elif hasattr(dashboard, 'new_template_btn'):
                                            logger.info("Bouton new_template_btn trouv√©")
                                            try:
                                                dashboard.new_template_btn.invoke()
                                                form_launched = True
                                            except Exception as e:
                                                logger.error(f"Erreur lors de l'appel √† invoke: {e}")
                                        
                                        # Chercher le bouton parmi les enfants du dashboard
                                        if not form_launched and hasattr(dashboard, 'winfo_children'):
                                            for child in dashboard.winfo_children():
                                                try:
                                                    # Essayer d'obtenir le texte du widget
                                                    child_text = ""
                                                    if hasattr(child, 'cget') and callable(getattr(child, 'cget')):
                                                        try:
                                                            child_text = child.cget('text')
                                                        except:
                                                            pass
                                                    
                                                    # Si c'est le bouton, l'activer
                                                    if 'cr√©er' in str(child_text).lower() and 'mod√®le' in str(child_text).lower():
                                                        if hasattr(child, 'invoke') and callable(getattr(child, 'invoke')):
                                                            child.invoke()
                                                            logger.info(f"Bouton 'Cr√©er un mod√®le' trouv√© et activ√©")
                                                            form_launched = True
                                                            break
                                                except Exception as e:
                                                    logger.error(f"Erreur avec un widget enfant: {e}")
                                                    continue
                        
                                # 5. Fallback: Ouvrir directement le document
                                if not form_launched and os.path.exists(document_path):
                                    logger.warning("Aucune m√©thode n'a fonctionn√©, ouverture du document avec l'application par d√©faut")
                                    import platform
                                    system = platform.system()
                                    if system == 'Windows':
                                        os.startfile(document_path)
                                    elif system == 'Darwin':  # macOS
                                        import subprocess
                                        subprocess.call(['open', document_path])
                                    else:  # Linux
                                        import subprocess
                                        subprocess.call(['xdg-open', document_path])
                                    logger.info(f"Document ouvert directement: {document_path}")
                                    
                                    # Informer l'utilisateur via une bo√Æte de dialogue si possible
                                    try:
                                        import tkinter as tk
                                        from tkinter import messagebox
                                        
                                        # Cr√©er une fen√™tre temporaire (invisible)
                                        temp_tk = tk.Tk()
                                        temp_tk.withdraw()  # Cacher la fen√™tre
                                        
                                        # Afficher le message
                                        messagebox.showinfo(
                                            "Ouverture du document",
                                            f"Le document '{selected_model}' a √©t√© ouvert directement.\n\n"
                                            "Pour le sauvegarder en tant que mod√®le, utilisez le bouton 'Cr√©er un mod√®le' dans l'application principale."
                                        )
                                        
                                        # D√©truire la fen√™tre temporaire
                                        temp_tk.destroy()
                                    except Exception as tk_error:
                                        logger.error(f"Erreur lors de l'affichage du message: {tk_error}")
                        except Exception as e:
                            logger.error(f"Erreur dans thread de formulaire: {e}")
                            import traceback
                            logger.error(traceback.format_exc())
                    
                    # Lancer le thread
                    thread = threading.Thread(target=launch_form_async)
                    thread.daemon = True
                    thread.start()
                    logger.info("Thread de lancement de formulaire d√©marr√©")
                except Exception as thread_error:
                    logger.error(f"Erreur lors du lancement du thread: {thread_error}")
                    self._form_thread_started = False
            
            except Exception as thread_error:
                logger.error(f"Erreur lors du lancement du thread: {thread_error}")
            
            # Toujours retourner le message de confirmation
            if form_opened:
                return """‚úÖ J'ai lanc√© l'√©diteur de mod√®le avec les informations que vous avez fournies.

Une fen√™tre devrait maintenant √™tre ouverte pour √©diter le document. 
Si vous ne la voyez pas, v√©rifiez qu'elle n'est pas masqu√©e derri√®re d'autres fen√™tres ou minimis√©e dans la barre des t√¢ches.

Le processus de remplissage est maintenant termin√©.
Avez-vous besoin d'autre chose ?"""
            else:
                return f"""‚ö†Ô∏è Je n'ai pas pu ouvrir automatiquement l'√©diteur de mod√®le.

Le document est disponible √† l'emplacement suivant:
{document_path}

Vous pouvez:
1. Ouvrir ce document manuellement 
2. Cliquer sur le bouton "Cr√©er un mod√®le" dans l'application principale
3. Essayer avec un autre document

Avez-vous besoin d'autre chose ?"""
            
        except Exception as e:
            logger.error(f"Erreur lors du remplissage du document: {e}")
            logger.error(traceback.format_exc())
            
            # Le contexte est d√©j√† r√©initialis√© au d√©but de la fonction
            
            return f"""‚ùå Une erreur s'est produite lors du traitement: {str(e)}

Le processus de remplissage a √©t√© annul√©.
Comment puis-je vous aider maintenant ?"""
            
    def _convert_form_info_to_variables(self, form_info):
        """
        Convertit les informations du formulaire en variables pour le mod√®le
        
        Args:
            form_info (list): Liste des informations fournies par l'utilisateur
            
        Returns:
            dict: Dictionnaire des variables pour le mod√®le
        """
        variables = {}
        
        # Traiter chaque √©l√©ment des informations du formulaire
        for i, info in enumerate(form_info):
            # Essayer de d√©tecter le type d'information
            if re.search(r'@|mail', info, re.IGNORECASE):
                variables[f"email_{i}"] = info
            elif re.search(r'\d{2}[/.-]\d{2}[/.-]\d{4}', info):
                variables[f"date_{i}"] = info
            elif re.search(r'\d+[.,]?\d*\s*(?:‚Ç¨|EUR|euro)', info, re.IGNORECASE):
                variables[f"montant_{i}"] = info
            elif re.search(r'\b(?:M|Mr|Mme|Mlle|Monsieur|Madame|Mademoiselle)\b', info, re.IGNORECASE):
                variables[f"nom_{i}"] = info
            elif re.search(r'\d{10}|\+\d{11,}', info):
                variables[f"telephone_{i}"] = info
            elif re.search(r'\d+\s+(?:rue|avenue|boulevard|place|chemin)', info, re.IGNORECASE):
                variables[f"adresse_{i}"] = info
            else:
                variables[f"info_{i}"] = info
        
        return variables
    
    # Ajouter une m√©thode pour obtenir le chemin du mod√®le correctement
    def get_model_path(self, category, model_name):
        """
        Obtient le chemin complet d'un mod√®le, en v√©rifiant si models_path existe et en le cr√©ant si n√©cessaire
        
        Args:
            category (str): La cat√©gorie du mod√®le
            model_name (str): Le nom du mod√®le
            
        Returns:
            str: Le chemin complet vers le fichier du mod√®le
        """
        # V√©rifier si le chemin des mod√®les existe et l'initialiser si n√©cessaire
        try:
            if not hasattr(self, 'models_path') or not self.models_path:
                # Tenter d'initialiser le chemin des mod√®les
                if hasattr(self, 'appmodel') and hasattr(self.appmodel, 'get_documents_path'):
                    self.models_path = self.appmodel.get_documents_path()
                    logger.info(f"Chemin des mod√®les obtenu via appmodel: {self.models_path}")
                else:
                    # Fallback: utiliser un chemin par d√©faut
                    self.models_path = os.path.join(os.getcwd(), "data", "documents", "types")
                    logger.info(f"Utilisation du chemin par d√©faut pour les mod√®les: {self.models_path}")
                    # Cr√©er le dossier s'il n'existe pas
                    if not os.path.exists(self.models_path):
                        os.makedirs(self.models_path, exist_ok=True)
                        logger.info(f"Dossier cr√©√©: {self.models_path}")
        except Exception as e:
            logger.error(f"Erreur lors de l'initialisation du chemin des mod√®les: {e}")
            # Utiliser un chemin par d√©faut en cas d'erreur
            self.models_path = os.path.join(os.getcwd(), "data", "documents", "types")
        
        # Construire et retourner le chemin complet
        path = os.path.join(self.models_path, category, model_name)
        logger.info(f"Chemin complet du mod√®le: {path}")
        return path
    
    # Ajouter la m√©thode √† AIModel
    AIModel.get_model_path = get_model_path
    
    # Autres m√©thodes utilitaires
    AIModel.is_return_command = is_return_command
    AIModel.is_reset_command = is_reset_command
    AIModel.is_complete_command = is_complete_command
    AIModel.reset_context = reset_context
    AIModel._convert_form_info_to_variables = _convert_form_info_to_variables
    
    logger.info("Patches appliqu√©s avec succ√®s")
    
    return AIModel 

def simulate_create_template_button_click(self):
    """
    Simule un clic sur le bouton "Cr√©er un mod√®le" du tableau de bord.
    Cette m√©thode permet d'acc√©der directement √† la fonctionnalit√© de cr√©ation de mod√®le
    depuis n'importe quel endroit de l'application.
    
    Returns:
        bool: True si le bouton a √©t√© trouv√© et cliqu√©, False sinon
    """
    logger.info("Tentative de simulation de clic sur le bouton 'Cr√©er un mod√®le' du dashboard")
    
    try:
        # 1. Chercher le dashboard
        dashboard = None
        dashboard_view = None
        
        # Chercher dans les attributs directs
        if hasattr(self, 'dashboard'):
            dashboard = self.dashboard
        elif hasattr(self, 'dashboard_view'):
            dashboard_view = self.dashboard_view
        
        # Chercher dans l'appmodel
        if not dashboard and not dashboard_view and hasattr(self, 'appmodel'):
            if hasattr(self.appmodel, 'dashboard'):
                dashboard = self.appmodel.dashboard
            elif hasattr(self.appmodel, 'dashboard_view'):
                dashboard_view = self.appmodel.dashboard_view
            # Chercher dans controllers
            elif hasattr(self.appmodel, 'controllers'):
                if hasattr(self.appmodel.controllers, 'dashboard_controller'):
                    if hasattr(self.appmodel.controllers.dashboard_controller, 'view'):
                        dashboard_view = self.appmodel.controllers.dashboard_controller.view
        
        # Chercher dans la fen√™tre principale
        if not dashboard and not dashboard_view:
            root = None
            if hasattr(self, 'root'):
                root = self.root
            elif hasattr(self, 'parent'):
                root = self.parent
            elif hasattr(self, 'appmodel') and hasattr(self.appmodel, 'root'):
                root = self.appmodel.root
                
            if root and hasattr(root, 'dashboard'):
                dashboard = root.dashboard
            elif root and hasattr(root, 'dashboard_view'):
                dashboard_view = root.dashboard_view
        
        # 2. Si on a trouv√© le dashboard_view, utiliser ses m√©thodes
        if dashboard_view:
            logger.info("DashboardView trouv√©, tentative d'acc√®s au bouton 'Cr√©er un mod√®le'")
            
            # Essayer d'utiliser la m√©thode callback directement
            if hasattr(dashboard_view, '_new_template_callback') and callable(dashboard_view._new_template_callback):
                logger.info("Appel de la m√©thode _new_template_callback")
                dashboard_view._new_template_callback()
                return True
                
            # Essayer d'acc√©der au bouton directement
            if hasattr(dashboard_view, 'new_template_btn'):
                logger.info("Acc√®s au bouton new_template_btn")
                if hasattr(dashboard_view.new_template_btn, 'invoke') and callable(dashboard_view.new_template_btn.invoke):
                    dashboard_view.new_template_btn.invoke()
                    return True
            
            # Essayer d'utiliser la fonction new_template
            if hasattr(dashboard_view, 'new_template') and callable(dashboard_view.new_template):
                logger.info("Appel de la fonction new_template")
                dashboard_view.new_template()
                return True
        
        # 3. Si on a trouv√© le dashboard, l'utiliser
        if dashboard:
            logger.info("Dashboard trouv√©, tentative d'acc√®s au bouton 'Cr√©er un mod√®le'")
            
            # Essayer d'utiliser la m√©thode new_template_callback
            if hasattr(dashboard, '_new_template_callback') and callable(dashboard._new_template_callback):
                logger.info("Appel de la m√©thode _new_template_callback")
                dashboard._new_template_callback()
                return True
                
            # Essayer d'acc√©der au bouton directement
            if hasattr(dashboard, 'new_template_btn'):
                logger.info("Acc√®s au bouton new_template_btn")
                if hasattr(dashboard.new_template_btn, 'invoke') and callable(dashboard.new_template_btn.invoke):
                    dashboard.new_template_btn.invoke()
                    return True
            
            # Essayer d'utiliser la fonction new_template
            if hasattr(dashboard, 'new_template') and callable(dashboard.new_template):
                logger.info("Appel de la fonction new_template")
                dashboard.new_template()
                return True
        
        logger.warning("Impossible de trouver le bouton 'Cr√©er un mod√®le'")
        return False
        
    except Exception as e:
        logger.error(f"Erreur lors de la simulation du clic sur 'Cr√©er un mod√®le': {e}")
        return False

# Ajouter la m√©thode √† AIModel
AIModel.simulate_create_template_button_click = simulate_create_template_button_click